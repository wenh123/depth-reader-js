/*!
 * MIT Licensed
 * https://github.com/IntelRealSense/depth-reader-js
 * XDM 1.0 spec: https://software.intel.com/en-us/articles/the-extensible-device-metadata-xdm-specification-version-10
 * Copyright Â© 2016 Intel Corporation
 */
"format global";(function(){"use strict";function a(a,b,c,e){/*
    XDM metadata are usually encoded using the Adobe XMP Toolkit,
    but the XMP serializer, for reasons not entirely understood--
    perhaps for compression, sometimes encodes properties as XML
    attributes instead of child elements; so we must handle both
    structural forms.
    */
var j=n(a,"VendorInfo"),k=n(a,"DevicePose"),l=n(a,"CameraPose"),m=n(a,"Device"),o=n(a,"Camera"),q=n(a,"DepthMap"),r=n(a,"NoiseModel"),s=n(a,"PerspectiveModel"),t=f(c,m,"Revision"),u=f(e,m,"VendorInfo")||f(c,m,"VendorInfo"),v=f(e,o,"VendorInfo"),w=f(e,m,"Pose")||f(c,m,"Pose"),x=f(e,o,"Pose"),y=d(f(e,o,"ImagingModel")),z=f(e,o,"Image"),A=d(f(e,o,"DepthMap",0)),B=f(e,o,"DepthMap",1),C=f(A,r,"Reliability");a.revision=+i(e,m,"Revision")||+g(t,m,"Revision")||+h(t),a.device.vendor.manufacturer=i(u,j,"Manufacturer")||g(u,j,"Manufacturer"),a.camera.vendor.manufacturer=i(v,j,"Manufacturer")||g(v,j,"Manufacturer"),a.device.vendor.model=i(u,j,"Model")||g(u,j,"Model"),a.camera.vendor.model=i(v,j,"Model")||g(v,j,"Model"),a.device.pose.latitude=+i(w,k,"Latitude")||+g(w,k,"Latitude"),a.device.pose.longitude=+i(w,k,"Longitude")||+g(w,k,"Longitude"),a.device.pose.altitude=+i(w,k,"Altitude")||+g(w,k,"Altitude"),a.camera.pose.positionX=+i(x,l,"PositionX")||+g(x,l,"PositionX"),a.camera.pose.positionY=+i(x,l,"PositionY")||+g(x,l,"PositionY"),a.camera.pose.positionZ=+i(x,l,"PositionZ")||+g(x,l,"PositionZ"),a.camera.pose.rotationAxisX=+i(x,l,"RotationAxisX")||+g(x,l,"RotationAxisX"),a.camera.pose.rotationAxisY=+i(x,l,"RotationAxisY")||+g(x,l,"RotationAxisY"),a.camera.pose.rotationAxisZ=+i(x,l,"RotationAxisZ")||+g(x,l,"RotationAxisZ"),a.camera.pose.rotationAngle=+i(x,l,"RotationAngle")||+g(x,l,"RotationAngle"),a.perspective.focalLengthX=+i(y,s,"FocalLengthX")||+g(y,s,"FocalLengthX"),a.perspective.focalLengthY=+i(y,s,"FocalLengthY")||+g(y,s,"FocalLengthY"),a.perspective.principalPointX=+i(y,s,"PrincipalPointX")||+g(y,s,"PrincipalPointX"),a.perspective.principalPointY=+i(y,s,"PrincipalPointY")||+g(y,s,"PrincipalPointY"),a.depth.metric=p(i(A,q,"Metric")||g(A,q,"Metric")),a.depth.format=i(A,q,"Format")||g(A,q,"Format"),a.depth.near=+i(A,q,"Near")||+g(A,q,"Near"),a.depth.far=+i(A,q,"Far")||+g(A,q,"Far"),a.image.mime=i(z,b,"Mime")||g(z,b,"Mime"),a.depth.mime=i(A,q,"Mime")||g(A,q,"Mime"),a.depth.raw.mime=i(B,q,"Mime")||g(B,q,"Mime"),a.confidence.mime=i(C,b,"Mime")||g(C,b,"Mime"),a.image.data=i(z,b,"Data")||g(z,b,"Data"),a.depth.data=i(A,q,"Data")||g(A,q,"Data"),a.depth.raw.data=i(B,q,"Data")||g(B,q,"Data"),a.confidence.data=i(C,b,"Data")||g(C,b,"Data")}function b(a,b,c,d){var e=n(a,"DepthMap"),f=n(a,"Focus");a.focus.focalPointX=+i(c,f,"FocalPointX"),a.focus.focalPointY=+i(c,f,"FocalPointY"),a.focus.focalDistance=+i(c,f,"FocalDistance"),a.focus.blurAtInfinity=+i(c,f,"BlurAtInfinity"),a.depth.format=i(c,e,"Format"),a.depth.near=+i(c,e,"Near"),a.depth.far=+i(c,e,"Far"),a.image.mime=i(c,b,"Mime"),a.depth.mime=i(c,e,"Mime"),a.image.data=i(d,b,"Data"),a.depth.data=i(d,e,"Data")}
// parse given XML and return x:xmpmeta
// -> rdf:RDF -> rdf:Description element
// (also reads namespaces for later use)
function c(a,b){try{var c=new v,f=c.parseFromString(b,"application/xml"),g=d(e(f.documentElement));
// no exception is thrown in browser if the input
// is empty string, but DOM contains <parsererror>
if("rdf:Description"===g.tagName)return m(a,g),g}catch(h){}throw new Error("cannot parse the XMP XML")}
// get child rdf:Description;
// return parent if not found
function d(a){for(var b=a&&a.childNodes||[],c=b.length-1;c>=0;c--)if("rdf:Description"===b[c].nodeName)return b[c];return a}function e(a){for(var b=a&&a.firstChild;b&&1!==b.nodeType;b=b.nextSibling);return b||null}function f(a,b,c,d){var e=a&&a.getElementsByTagNameNS(b,c);return e&&e[0|d]||null}function g(a,b,c){return h(f(a,b,c))}function h(a){return a&&a.textContent||""}function i(a,b,c){return a&&a.getAttributeNS(b,c)||""}
// make image.data a data URI
function j(a){a.mime&&a.data&&(a.data="data:"+a.mime+";base64,"+a.data)}/*
  get index of next APP1 marker
  pos: starting index within buf
  return: index; -1 if not found
  */
function k(a,b){for(var c=b;c<a.length;c++)if(255===a[c]&&225===a[c+1])return c;return-1}/*
  get XMP segment header string
  pos: starting index of segment
  return: header; '' if not found
  */
function l(a,b){function c(c){var d=o(a,b,c.length);return c===d}// skip segment size
return b+=2,c(A)?A:c(B)?B:""}function m(a,b){for(var c=a._namespaces,d=b&&b.attributes||[],e=d.length-1;e>=0;e--){var f=d[e].name,g=d[e].value;/^xmlns:/.test(f)&&/^http:\/\/ns\.(xdm\.org|google\.com)\//.test(g)&&(c[f.slice(6)]=g.toLowerCase())}}
// name: get namespace with
//   URI ending in /{name}/
function n(a,b){var c=a._namespaces,d=Object.keys(c);b="/"+b.toLowerCase()+"/";for(var e=d.length-1;e>=0;e--){var f=d[e],g=c[f],h=g.length-b.length;if(b===g.slice(h))return g}return""}
// convert sub-Uint8Array to string
function o(a,b,c){var d=a.subarray||a.slice;a=d.call(a,b,b+c);try{return String.fromCharCode.apply(null,a)}catch(e){for(
// work around PhantomJS bug:
// https://github.com/ariya/phantomjs/issues/11172
var f=-1,g=a.length,h=new Array(g);++f<g;)h[f]=a[f];return String.fromCharCode.apply(null,h)}}
// parse '1'/'true'/'yes'
function p(a){return!!String(a).match(/^\s*1|true|yes\s*$/i)}function q(a,b){return new t(function(c,d){b||(b=new x),b.onload=function(){c(b)},b.onerror=function(){d(new Error("cannot load image"))},b.src=a})}function r(a,b){if(w)// Node.js
return new w(a,b);var c=document.createElement("canvas");return c.width=a,c.height=b,c}var s,t,u,v,w,x,y=this;"undefined"==typeof window?(s="buffer",t=require("rsvp").Promise,u=require("xhr2"),v=require("xmldom").DOMParser,w=require("canvas"),x=w.Image):(s="arraybuffer",t=y.Promise||y.RSVP.Promise,u=y.XMLHttpRequest,v=y.DOMParser,x=y.Image);var z=function(){this._namespaces={},this.isXDM=!1,this.revision=0,this.device={vendor:{manufacturer:"",model:""},pose:{latitude:0,longitude:0,altitude:0}},this.camera={vendor:{manufacturer:"",model:""},pose:{positionX:0,positionY:0,positionZ:0,rotationAxisX:0,rotationAxisY:0,rotationAxisZ:0,rotationAngle:0}},this.perspective={// XDM
focalLengthX:0,focalLengthY:0,principalPointX:0,principalPointY:0},this.focus={// Lens Blur
focalPointX:0,focalPointY:0,focalDistance:0,blurAtInfinity:0},this.image={mime:"",data:null},this.depth={metric:!1,format:"",near:0,far:0,mime:"",data:null,raw:{mime:"",data:null}},this.confidence={mime:"",data:null}};/**
   * parse XDM/LensBlur JPEG given its ArrayBuffer
   * (function is synchronous and returns nothing;
   * exception will be thrown if parsing fails)
   *
   * @param {ArrayBuffer|Buffer} buffer - JPEG image
   */
z.prototype.parseFile=function(d){var e=d instanceof Uint8Array?d:new Uint8Array(d);if(255!==e[0]||216!==e[1])// JPEG start-of-image
throw new Error("file is not a JPEG image");for(var f,g,h="",i="",m=0;-1<(m=k(e,m));)// skip marker to segment start
if(m+=2,g=l(e,m)){
// payload start = segment start + header length
//               + sizeof word + null-terminator
// if extension: + 32-byte HasExtendedXMP UUID
//               +  8-byte "I don't know/care"
var p=A===g,q=g.length+(p?3:43),r=(e[m]<<8)+e[m+1]-q,s=m+q;m=s+r,f=o(e,s,r),p?h+=f:i+=f}this.debug&&!this.xmpExtXml&&(
// expose XMP XML for inspection
// unless injected (for testing)
this.xmpXapXml=h,this.xmpExtXml=i);var t=c(this,this.xmpXapXml||h),u=c(this,this.xmpExtXml||i),v=n(this,"Image");this.isXDM=/xdm\.org/.test(v),(this.isXDM?a:b).call(null,this,v,t,u),[this.image,this.depth,this.depth.raw,this.confidence].forEach(j)};var A="http://ns.adobe.com/xap/1.0/",B="http://ns.adobe.com/xmp/extension/";/**
   * load XDM/LensBlur image given JPEG file URL
   * (parseFile() will be invoked automatically)
   *
   * @param {string} fileUrl - URL for XMLHttpRequest
   * @return Promise that will be resolved with _this_
  */
z.prototype.loadFile=function(a){var b=this;return new t(function(c,d){var e;try{var f=new u;f.open("GET",a),f.responseType=s,f.onload=function(){if(2===(this.status/100|0))try{// parsing is synchronous
b.fileData=this.response,b.parseFile.call(b,b.fileData),c(b)}catch(a){d(a)}else e="cannot load file ["+this.status+"]",this.response&&this.response.length&&(e+=": "+o(this.response,0,50).trim()),d(new Error(e))},f.onerror=function(){e="cannot load file: ",e+=/^file:/.test(a)?"file not found":"host not found",d(new Error(e))},f.send()}catch(g){e=g.message||"URL protocol error",d(new Error(e))}})},/**
   * normalize the XDM depthmap so that depth
   * values are distributed between 0 and 255
   * (overwrites the original depth.data)
   *
   * @param {string} [func] - name of a registered normalizer
   *                          function (default is "default")
   * @param {object} [opts] - options passed to normalizer
   * @return Promise that will be resolved with modified
   *         depth.data
   */
z.prototype.normalizeDepthMap=function(a,b){function c(c){var e=c.width,f=c.height,g=r(e,f),h=g.getContext("2d");h.drawImage(c,0,0);var i=h.getImageData(0,0,e,f),j=i.data;try{a.call(g,j,b)}catch(k){var l="normalizer failed: "+k.message.trim();throw new Error(l)}
// type + encoder options added
// to work around PhantomJS bug:
// https://github.com/ariya/phantomjs/issues/10455
return h.putImageData(i,0,0),j=g.toDataURL("image/png",0),d.data=j}var d=this.depth;if(!d.data||!this.isXDM)// not applicable
return t.resolve(d.data);if("string"!=typeof a&&(b=a,a="default"),"object"!=typeof b?
// backward compatibility
// for default normalizer
b={bias:b}:b||(b={bias:0}),!(a=C[a])){var e=new Error("normalizer not registered");return t.reject(e)}return d._origImage?new t(function(a,b){try{a(c(d._origImage))}catch(e){b(e)}}):q(d.data).then(function(a){return d._origImage=a}).then(c)},/**
   * register a normalizer function
   * for use by normalizeDepthMap()
   *
   * @param {string}   name - name to identify normalizer
   * @param {function} func - function(data, opts) where
   *        data (Uint8ClampedArray) is ImageData.data
   *        array that should be modified, opts (object)
   *        contains normalizer-specific options, _this_
   *        is Canvas
   */
z.registerNormalizer=function(a,b){if("string"!=typeof a||"function"!=typeof b)throw new Error("invalid name and/or func");C[a]=b};var C={};C["default"]=function(a,b){
// min percent of total depthmap pixels
// for determining min/max depth values
var c,d,e,f,g,h,i,j=new Int32Array(256),k=0|b.bias,l=a.length,m=l/4,n=isNaN(+b.threshold)?.1:+b.threshold,o=255,p=0;
// get min/max depth values
for(g=0;l>g;g+=4)++j[c=a[g]],c>p&&(p=c),o>c&&(o=c);
// discard min/max outliers
for(g=o;p>g&&(d=j[g]/m*100,!(d>=n));g++);for(h=p;h>o&&(d=j[h]/m*100,!(d>=n));h--);for(h-g>0&&(o=g,p=h),i=255/(p-o+1),g=0;l>g;g+=4)
// modify R,G,B not alpha
for(f!==(c=a[g])&&(f=c,c=Math.max(0,Math.min(c,p)-o),e=Math.round(c*i+k)),h=0;3>h;h++)a[g+h]=e},z.prototype.toJSON=function(){var a=this.device.vendor,b=this.device.pose,c=this.camera.vendor,d=this.camera.pose,e=this.perspective,f=this.focus,g=this.depth;/* jshint camelcase: false */
/* jshint camelcase: false */
return this.isXDM?{is_xdm:!0,revision:this.revision,device:{vendor:{manufacturer:a.manufacturer,model:a.model},pose:{latitude:b.latitude,longitude:b.longitude,altitude:b.altitude}},camera:{vendor:{manufacturer:c.manufacturer,model:c.model},pose:{position_x:d.positionX,position_y:d.positionY,position_z:d.positionZ,rotation_axis_x:d.rotationAxisX,rotation_axis_y:d.rotationAxisY,rotation_axis_z:d.rotationAxisZ,rotation_angle:d.rotationAngle}},perspective:{focal_length_x:e.focalLengthX,focal_length_y:e.focalLengthY,principal_point_x:e.principalPointX,principal_point_y:e.principalPointY},depth:{metric:g.metric,format:g.format,near:g.near,far:g.far}}:{is_xdm:!1,focus:{focal_point_x:f.focalPointX,focal_point_y:f.focalPointY,focal_distance:f.focalDistance,blur_at_infinity:f.blurAtInfinity},depth:{format:g.format,near:g.near,far:g.far}}},"undefined"==typeof window?module.exports=z:y.DepthReader=z}).call(this);
//# sourceMappingURL=depth-reader.min.js.map